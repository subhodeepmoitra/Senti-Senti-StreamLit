/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_CONVERTFLOATNVIDIAPASS
#define GEN_PASS_DECL_CONVERTINDEXTYPEPASS
#define GEN_PASS_DECL_FUSELOOPSPASS
#define GEN_PASS_DECL_OPTIMIZELOOPSPASS
#define GEN_PASS_DECL_PEELLOOPSPASS
#define GEN_PASS_DECL_VECTORIZELOADSANDSTORESPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// ConvertFloatNvidiaPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTFLOATNVIDIAPASS
#undef GEN_PASS_DECL_CONVERTFLOATNVIDIAPASS
#endif // GEN_PASS_DECL_CONVERTFLOATNVIDIAPASS
#ifdef GEN_PASS_DEF_CONVERTFLOATNVIDIAPASS
namespace impl {

template <typename DerivedT>
class ConvertFloatNvidiaPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertFloatNvidiaPassBase;

  ConvertFloatNvidiaPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertFloatNvidiaPassBase(const ConvertFloatNvidiaPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ConvertFloatNvidiaPassBase& operator=(const ConvertFloatNvidiaPassBase &) = delete;
  ConvertFloatNvidiaPassBase(ConvertFloatNvidiaPassBase &&) = delete;
  ConvertFloatNvidiaPassBase& operator=(ConvertFloatNvidiaPassBase &&) = delete;
  ~ConvertFloatNvidiaPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-convert-float-nvidia");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-convert-float-nvidia"; }

  ::llvm::StringRef getDescription() const override { return "Convert floating point types using NVidia intrinsics."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertFloatNvidiaPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertFloatNvidiaPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertFloatNvidiaPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTFLOATNVIDIAPASS
#endif // GEN_PASS_DEF_CONVERTFLOATNVIDIAPASS

//===----------------------------------------------------------------------===//
// ConvertIndexTypePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTINDEXTYPEPASS
#undef GEN_PASS_DECL_CONVERTINDEXTYPEPASS
#endif // GEN_PASS_DECL_CONVERTINDEXTYPEPASS
#ifdef GEN_PASS_DEF_CONVERTINDEXTYPEPASS
namespace impl {

template <typename DerivedT>
class ConvertIndexTypePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertIndexTypePassBase;

  ConvertIndexTypePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertIndexTypePassBase(const ConvertIndexTypePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ConvertIndexTypePassBase& operator=(const ConvertIndexTypePassBase &) = delete;
  ConvertIndexTypePassBase(ConvertIndexTypePassBase &&) = delete;
  ConvertIndexTypePassBase& operator=(ConvertIndexTypePassBase &&) = delete;
  ~ConvertIndexTypePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-convert-index-type");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-convert-index-type"; }

  ::llvm::StringRef getDescription() const override { return "Converts index types to module data layout index type."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertIndexTypePass");
  }
  ::llvm::StringRef getName() const override { return "ConvertIndexTypePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertIndexTypePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTINDEXTYPEPASS
#endif // GEN_PASS_DEF_CONVERTINDEXTYPEPASS

//===----------------------------------------------------------------------===//
// FuseLoopsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_FUSELOOPSPASS
#undef GEN_PASS_DECL_FUSELOOPSPASS
#endif // GEN_PASS_DECL_FUSELOOPSPASS
#ifdef GEN_PASS_DEF_FUSELOOPSPASS
namespace impl {

template <typename DerivedT>
class FuseLoopsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FuseLoopsPassBase;

  FuseLoopsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FuseLoopsPassBase(const FuseLoopsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  FuseLoopsPassBase& operator=(const FuseLoopsPassBase &) = delete;
  FuseLoopsPassBase(FuseLoopsPassBase &&) = delete;
  FuseLoopsPassBase& operator=(FuseLoopsPassBase &&) = delete;
  ~FuseLoopsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-fuse-loops");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-fuse-loops"; }

  ::llvm::StringRef getDescription() const override { return "Fuse xla_gpu.loop."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FuseLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "FuseLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<xla::gpu::XlaGpuDialect>();
    registry.insert<xla::XlaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FuseLoopsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_FUSELOOPSPASS
#endif // GEN_PASS_DEF_FUSELOOPSPASS

//===----------------------------------------------------------------------===//
// OptimizeLoopsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_OPTIMIZELOOPSPASS
#undef GEN_PASS_DECL_OPTIMIZELOOPSPASS
#endif // GEN_PASS_DECL_OPTIMIZELOOPSPASS
#ifdef GEN_PASS_DEF_OPTIMIZELOOPSPASS
namespace impl {

template <typename DerivedT>
class OptimizeLoopsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = OptimizeLoopsPassBase;

  OptimizeLoopsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  OptimizeLoopsPassBase(const OptimizeLoopsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  OptimizeLoopsPassBase& operator=(const OptimizeLoopsPassBase &) = delete;
  OptimizeLoopsPassBase(OptimizeLoopsPassBase &&) = delete;
  OptimizeLoopsPassBase& operator=(OptimizeLoopsPassBase &&) = delete;
  ~OptimizeLoopsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-optimize-loops");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-optimize-loops"; }

  ::llvm::StringRef getDescription() const override { return "Unrolls and pipelines loops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OptimizeLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "OptimizeLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::vector::VectorDialect>();
    registry.insert<xla::gpu::XlaGpuDialect>();
    registry.insert<xla::XlaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OptimizeLoopsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_OPTIMIZELOOPSPASS
#endif // GEN_PASS_DEF_OPTIMIZELOOPSPASS

//===----------------------------------------------------------------------===//
// PeelLoopsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_PEELLOOPSPASS
#undef GEN_PASS_DECL_PEELLOOPSPASS
#endif // GEN_PASS_DECL_PEELLOOPSPASS
#ifdef GEN_PASS_DEF_PEELLOOPSPASS
namespace impl {

template <typename DerivedT>
class PeelLoopsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = PeelLoopsPassBase;

  PeelLoopsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  PeelLoopsPassBase(const PeelLoopsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  PeelLoopsPassBase& operator=(const PeelLoopsPassBase &) = delete;
  PeelLoopsPassBase(PeelLoopsPassBase &&) = delete;
  PeelLoopsPassBase& operator=(PeelLoopsPassBase &&) = delete;
  ~PeelLoopsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-peel-loops");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-peel-loops"; }

  ::llvm::StringRef getDescription() const override { return "Peels xla_gpu.loop."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PeelLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "PeelLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<xla::gpu::XlaGpuDialect>();
    registry.insert<xla::XlaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PeelLoopsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_PEELLOOPSPASS
#endif // GEN_PASS_DEF_PEELLOOPSPASS

//===----------------------------------------------------------------------===//
// VectorizeLoadsAndStoresPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_VECTORIZELOADSANDSTORESPASS
struct VectorizeLoadsAndStoresPassOptions {
  std::string gpu_device_info_;
};
#undef GEN_PASS_DECL_VECTORIZELOADSANDSTORESPASS
#endif // GEN_PASS_DECL_VECTORIZELOADSANDSTORESPASS
#ifdef GEN_PASS_DEF_VECTORIZELOADSANDSTORESPASS
namespace impl {

template <typename DerivedT>
class VectorizeLoadsAndStoresPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = VectorizeLoadsAndStoresPassBase;

  VectorizeLoadsAndStoresPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  VectorizeLoadsAndStoresPassBase(const VectorizeLoadsAndStoresPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  VectorizeLoadsAndStoresPassBase& operator=(const VectorizeLoadsAndStoresPassBase &) = delete;
  VectorizeLoadsAndStoresPassBase(VectorizeLoadsAndStoresPassBase &&) = delete;
  VectorizeLoadsAndStoresPassBase& operator=(VectorizeLoadsAndStoresPassBase &&) = delete;
  ~VectorizeLoadsAndStoresPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-vectorize-loads-stores");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-vectorize-loads-stores"; }

  ::llvm::StringRef getDescription() const override { return "Vectorizes loads and stores."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VectorizeLoadsAndStoresPass");
  }
  ::llvm::StringRef getName() const override { return "VectorizeLoadsAndStoresPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VectorizeLoadsAndStoresPassBase<DerivedT>)

  VectorizeLoadsAndStoresPassBase(VectorizeLoadsAndStoresPassOptions options) : VectorizeLoadsAndStoresPassBase() {
    gpu_device_info_ = std::move(options.gpu_device_info_);
  }
protected:
  ::mlir::Pass::Option<std::string> gpu_device_info_{*this, "gpu_device_info", ::llvm::cl::desc("Serialized stream_executor::GPUDeviceInfo proto.")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_VECTORIZELOADSANDSTORESPASS
#endif // GEN_PASS_DEF_VECTORIZELOADSANDSTORESPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// ConvertFloatNvidiaPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertFloatNvidiaPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateConvertFloatNvidiaPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertFloatNvidiaPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateConvertFloatNvidiaPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertIndexTypePass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertIndexTypePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateConvertIndexTypePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertIndexTypePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateConvertIndexTypePass();
  });
}

//===----------------------------------------------------------------------===//
// FuseLoopsPass Registration
//===----------------------------------------------------------------------===//

inline void registerFuseLoopsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateFuseLoopsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerFuseLoopsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateFuseLoopsPass();
  });
}

//===----------------------------------------------------------------------===//
// OptimizeLoopsPass Registration
//===----------------------------------------------------------------------===//

inline void registerOptimizeLoopsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateOptimizeLoopsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerOptimizeLoopsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateOptimizeLoopsPass();
  });
}

//===----------------------------------------------------------------------===//
// PeelLoopsPass Registration
//===----------------------------------------------------------------------===//

inline void registerPeelLoopsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreatePeelLoopsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerPeelLoopsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreatePeelLoopsPass();
  });
}

//===----------------------------------------------------------------------===//
// VectorizeLoadsAndStoresPass Registration
//===----------------------------------------------------------------------===//

inline void registerVectorizeLoadsAndStoresPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateVectorizeLoadsAndStoresPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerVectorizeLoadsAndStoresPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateVectorizeLoadsAndStoresPass();
  });
}

//===----------------------------------------------------------------------===//
// GpuFusionTransforms Registration
//===----------------------------------------------------------------------===//

inline void registerGpuFusionTransformsPasses() {
  registerConvertFloatNvidiaPass();
  registerConvertIndexTypePass();
  registerFuseLoopsPass();
  registerOptimizeLoopsPass();
  registerPeelLoopsPass();
  registerVectorizeLoadsAndStoresPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class ConvertFloatNvidiaPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertFloatNvidiaPassBase;

  ConvertFloatNvidiaPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertFloatNvidiaPassBase(const ConvertFloatNvidiaPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ConvertFloatNvidiaPassBase& operator=(const ConvertFloatNvidiaPassBase &) = delete;
  ConvertFloatNvidiaPassBase(ConvertFloatNvidiaPassBase &&) = delete;
  ConvertFloatNvidiaPassBase& operator=(ConvertFloatNvidiaPassBase &&) = delete;
  ~ConvertFloatNvidiaPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-convert-float-nvidia");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-convert-float-nvidia"; }

  ::llvm::StringRef getDescription() const override { return "Convert floating point types using NVidia intrinsics."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertFloatNvidiaPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertFloatNvidiaPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertFloatNvidiaPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertIndexTypePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertIndexTypePassBase;

  ConvertIndexTypePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertIndexTypePassBase(const ConvertIndexTypePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ConvertIndexTypePassBase& operator=(const ConvertIndexTypePassBase &) = delete;
  ConvertIndexTypePassBase(ConvertIndexTypePassBase &&) = delete;
  ConvertIndexTypePassBase& operator=(ConvertIndexTypePassBase &&) = delete;
  ~ConvertIndexTypePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-convert-index-type");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-convert-index-type"; }

  ::llvm::StringRef getDescription() const override { return "Converts index types to module data layout index type."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertIndexTypePass");
  }
  ::llvm::StringRef getName() const override { return "ConvertIndexTypePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertIndexTypePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class FuseLoopsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FuseLoopsPassBase;

  FuseLoopsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FuseLoopsPassBase(const FuseLoopsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  FuseLoopsPassBase& operator=(const FuseLoopsPassBase &) = delete;
  FuseLoopsPassBase(FuseLoopsPassBase &&) = delete;
  FuseLoopsPassBase& operator=(FuseLoopsPassBase &&) = delete;
  ~FuseLoopsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-fuse-loops");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-fuse-loops"; }

  ::llvm::StringRef getDescription() const override { return "Fuse xla_gpu.loop."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FuseLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "FuseLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<xla::gpu::XlaGpuDialect>();
    registry.insert<xla::XlaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FuseLoopsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class OptimizeLoopsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = OptimizeLoopsPassBase;

  OptimizeLoopsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  OptimizeLoopsPassBase(const OptimizeLoopsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  OptimizeLoopsPassBase& operator=(const OptimizeLoopsPassBase &) = delete;
  OptimizeLoopsPassBase(OptimizeLoopsPassBase &&) = delete;
  OptimizeLoopsPassBase& operator=(OptimizeLoopsPassBase &&) = delete;
  ~OptimizeLoopsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-optimize-loops");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-optimize-loops"; }

  ::llvm::StringRef getDescription() const override { return "Unrolls and pipelines loops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OptimizeLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "OptimizeLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::vector::VectorDialect>();
    registry.insert<xla::gpu::XlaGpuDialect>();
    registry.insert<xla::XlaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OptimizeLoopsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class PeelLoopsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = PeelLoopsPassBase;

  PeelLoopsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  PeelLoopsPassBase(const PeelLoopsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  PeelLoopsPassBase& operator=(const PeelLoopsPassBase &) = delete;
  PeelLoopsPassBase(PeelLoopsPassBase &&) = delete;
  PeelLoopsPassBase& operator=(PeelLoopsPassBase &&) = delete;
  ~PeelLoopsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-peel-loops");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-peel-loops"; }

  ::llvm::StringRef getDescription() const override { return "Peels xla_gpu.loop."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PeelLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "PeelLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<xla::gpu::XlaGpuDialect>();
    registry.insert<xla::XlaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PeelLoopsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class VectorizeLoadsAndStoresPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = VectorizeLoadsAndStoresPassBase;

  VectorizeLoadsAndStoresPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  VectorizeLoadsAndStoresPassBase(const VectorizeLoadsAndStoresPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  VectorizeLoadsAndStoresPassBase& operator=(const VectorizeLoadsAndStoresPassBase &) = delete;
  VectorizeLoadsAndStoresPassBase(VectorizeLoadsAndStoresPassBase &&) = delete;
  VectorizeLoadsAndStoresPassBase& operator=(VectorizeLoadsAndStoresPassBase &&) = delete;
  ~VectorizeLoadsAndStoresPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-vectorize-loads-stores");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-vectorize-loads-stores"; }

  ::llvm::StringRef getDescription() const override { return "Vectorizes loads and stores."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VectorizeLoadsAndStoresPass");
  }
  ::llvm::StringRef getName() const override { return "VectorizeLoadsAndStoresPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VectorizeLoadsAndStoresPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> gpu_device_info_{*this, "gpu_device_info", ::llvm::cl::desc("Serialized stream_executor::GPUDeviceInfo proto.")};
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
